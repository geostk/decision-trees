#raw idea

if args.validation_algorithm == "holdout":
	sets = dataset.getSets(trainingSet_pc)
	trainingSet = TrainingSet(sets[0])
	validationSet = ValidationSet(sets[1],args.classifier)

	tree = algorithm(args.classifier)
	accuracy = validationSet.validateTree(tree)
elif args.validation_algorithm == "cross-validation":
	k = args.k
	p = 1/k
	tr = k-1*p
	vd = p
	sets = dataset.getSets(1)
	
	full_dts = sets[0]
	size = len(full_dts)
	
	size_partition= size / k
	parts = []
	for i in range(k):
		parts.append(full_dts[i*size_partition:(i+1)*size_partition])

	accuracy = -1.0
	a = []
	for i in range(k):
		tr =parts[:i]+parts[i+1:]
		vd = parts[i]
		trainingSet = TrainingSet(tr)
		validationSet = ValidationSet(vd,args.classifier)
		t = algorithm(args.classifier)
	   	a.append(validationSet.validateTree(tree))
	
		if a[i]> accuracy:
			accuracy = a[i]
			tree = t
	
	tree t es el mejor con la mejor accuracy a
